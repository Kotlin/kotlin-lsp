// Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.jetbrains.ls.api.features.textEdits

import com.github.difflib.DiffUtils
import com.github.difflib.patch.Patch
import com.jetbrains.lsp.protocol.Position
import com.jetbrains.lsp.protocol.Range
import com.jetbrains.lsp.protocol.TextEdit

object TextEditsComputer {
    /**
     * Represents the level on which the diff is calculated. For some refactorings it might be more convenient to delete
     * the word and add word, rather than show several changes within single file
     */
    enum class DiffGranularity { CHARACTER, WORD }


    /**
     * Calculates the difference between 2 strings in the format convenient for LSP clients [TextEdit]
     * @see DiffGranularity
     */
    fun computeTextEdits(
        oldText: String,
        newText: String,
        granularity: DiffGranularity = DiffGranularity.CHARACTER
    ): List<TextEdit> {
        // Code is mostly generated by ai.
        //
        // Precompute line breaks in oldText to quickly get line/character from an index
        // We'll build an array of the cumulative indices of newlines.
        // For example, if oldText = "abc\ndef\ng", then lineBreakPositions might be [3, 7].
        // So offsets <= 3 are line 0, offsets <= 7 are line 1, etc.
        val lineBreakPositions = mutableListOf<Int>()
        oldText.forEachIndexed { i, c ->
            if (c == '\n') {
                lineBreakPositions.add(i)
            }
        }

        /**
         * Helper to map a 0-based character offset in oldText into (line, character).
         */
        fun offsetToPosition(offset: Int): Position {
            // You can do a binary search for performance; here we just do a linear scan for clarity
            var line = 0
            for (br in lineBreakPositions) {
                if (offset <= br) break
                line++
            }

            // If line is zero, `offset` is the character index in line 0.
            // If line > 0, we can figure out how many chars we've passed up to line-1
            val lineStartOffset = if (line == 0) 0 else lineBreakPositions[line - 1] + 1
            val characterInLine = offset - lineStartOffset
            return Position(line, characterInLine)
        }

        val edits = mutableListOf<TextEdit>()

        when (granularity) {
            DiffGranularity.CHARACTER -> {
                // 1) Convert both strings to a list of characters (including '\n')
                val oldChars = oldText.toList()
                val newChars = newText.toList()

                // 2) Compute the diff
                val patch: Patch<Char> = DiffUtils.diff(oldChars, newChars)

                // Build TextEdits for each delta
                for (delta in patch.deltas) {
                    val source = delta.source
                    val sourcePos = source.position   // start index in oldChars
                    val sourceSize = source.size()

                    // Revised chunk
                    val target = delta.target
                    val newSegment = target.lines.joinToString(separator = "") { it.toString() }

                    // Convert the old range: [sourcePos, sourcePos + sourceSize) to LSP Range
                    val startPos = offsetToPosition(sourcePos)
                    val endPos = offsetToPosition(sourcePos + sourceSize)

                    edits.add(
                        TextEdit(
                            range = Range(startPos, endPos),
                            newText = newSegment
                        )
                    )
                }
            }
            DiffGranularity.WORD -> {
                val oldTokens = tokenize(oldText)
                val newTokens = tokenize(newText)

                val patch: Patch<String> = DiffUtils.diff(
                    oldTokens.map { it.text },
                    newTokens.map { it.text }
                )

                for (delta in patch.deltas) {
                    val source = delta.source
                    val sourcePos = source.position
                    val sourceSize = source.size()

                    val target = delta.target
                    val targetPos = target.position
                    val targetSize = target.size()

                    val (startOffset, endOffset) = if (sourceSize > 0) {
                        // if this is a change offset is [startToken.start, endToken.end)
                        val start = oldTokens[sourcePos].start
                        val end = oldTokens[sourcePos + sourceSize - 1].end
                        start to end
                    } else {
                        // if this is insertion offset is [startToken.start, startToken.start)
                        val insertionOffset = if (sourcePos < oldTokens.size) oldTokens[sourcePos].start else oldText.length
                        insertionOffset to insertionOffset
                    }

                    val newSegment = newTokens.subList(targetPos, targetPos + targetSize).joinToString("") { it.text }

                    val startPos = offsetToPosition(startOffset)
                    val endPos = offsetToPosition(endOffset)

                    edits.add(
                        TextEdit(
                            range = Range(startPos, endPos),
                            newText = newSegment
                        )
                    )
                }
            }
        }

        return edits
    }

    /**
     * Splits string `s` into [Token]s.
     */
    private fun tokenize(s: String): List<Token> {
        if (s.isEmpty()) return emptyList()

        val res = mutableListOf<Token>()
        var i = 0
        while (i < s.length) {
            val c = s[i]
            if (isWordChar(c)) {
                val start = i
                var j = i + 1
                while (j < s.length && isWordChar(s[j])) j++
                res.add(Token(s.substring(start, j), start, j))
                i = j
            } else {
                val start = i
                val end = i + 1
                res.add(Token(s.substring(start, end), start, end))
                i = end
            }
        }
        return res
    }

    private fun isWordChar(c: Char): Boolean = c.isLetterOrDigit() || c == '_'

    /**
     * A non-whitespace sequence of letters, digits or underscore characters.
     */
    private class Token(val text: String, val start: Int, val end: Int)
}